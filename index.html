<!DOCTYPE html>
<html>
<head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.55.2/phaser.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
<script>
class MenuScene extends Phaser.Scene {
    constructor() {
        super({ key: 'MenuScene' });
    }

    preload() {
        this.load.image('madera', 'assets/madera.jpg');
        this.load.image('rio', 'assets/rio.jpg');
        this.load.image('galaxia', 'assets/galaxia.jpg');
        this.load.image('mercado', 'assets/mercado.jpg');
        this.load.audio('musica', 'assets/fondo.mp3');
    }

    create() {
        this.add.image(400, 300, 'madera').setScale(1.2);
        this.add.text(250, 100, 'Selecciona un Mapa', { fontSize: '32px', fill: '#ffffff' });

        let rioButton = this.add.text(350, 200, 'Rio', { fontSize: '24px', fill: '#00ff00' }).setInteractive();
        let galaxiaButton = this.add.text(350, 250, 'Galaxia', { fontSize: '24px', fill: '#00ffff' }).setInteractive();
        let mercadoButton = this.add.text(350, 300, 'Mercado', { fontSize: '24px', fill: '#ffcc00' }).setInteractive();

        rioButton.on('pointerdown', () => this.startGame('rio'));
        galaxiaButton.on('pointerdown', () => this.startGame('galaxia'));
        mercadoButton.on('pointerdown', () => this.startGame('mercado'));

        this.music = this.sound.add('musica', { loop: true, volume: 0.5 });
        this.music.play();
 // BotÃ³n de mute
        this.isMuted = false;
        this.muteButton = this.add.text(730, 10, 'ðŸ”Š', {
            fontSize: '24px',
            fill: '#ffffff',
            backgroundColor: '#000000',
            padding: { x: 10, y: 5 }
        }).setInteractive();

        this.muteButton.on('pointerdown', () => {
            this.isMuted = !this.isMuted;
            this.sound.mute = this.isMuted;
            this.muteButton.setText(this.isMuted ? 'ðŸ”‡' : 'ðŸ”Š');
        });
}
    startGame(map) {
        this.scene.start('TowerDefenseGame', { selectedMap: map });
    }
}

class TowerDefenseGame extends Phaser.Scene {
    constructor() {
        super({ key: 'TowerDefenseGame' });
    }

    init(data) {
        this.selectedMap = data.selectedMap;
        this.round = 1; // Contador de rondas
        this.enemiesDefeated = 0; // Contador de enemigos derrotados
        this.initialEnemiesPerRound = 1; // NÃºmero de enemigos en la primera ronda
        this.enemySpawnInterval = 2; // Intervalo de apariciÃ³n inicial
    }

    preload() {
        this.load.image('verde', 'assets/verde.png');
        this.load.image('azul', 'assets/azul.png');
        this.load.image('rojo', 'assets/rojo.png');
        this.load.image('morada', 'assets/morada.png');
        this.load.image('amarilla', 'assets/amarilla.png');
        this.load.image('bala', 'assets/bala.png');
    }

    create() {
        this.lives = 100;
        this.money = 100;
        this.selectedTower = null;
        this.add.image(400, 300, this.selectedMap).setScale(1);

        this.path = this.createPath();
        this.graphics = this.add.graphics();
        this.drawPath();

        this.enemies = [];
        this.towers = [];
        this.bullets = this.add.group();

        // Temporizador para spawn de enemigos
        this.spawnTimer = this.time.addEvent({
            delay: this.enemySpawnInterval,
            callback: this.spawnEnemy,
            callbackScope: this,
            loop: true
        });

        this.createUI();
        this.setupTowerPlacement();

        this.time.addEvent({
            delay: 500,
            callback: this.shootFromTowers,
            callbackScope: this,
            loop: true
        });

        this.infoText = this.add.text(10, 10, '', { fontSize: '18px', fill: '#ffffff' });
        this.roundText = this.add.text(10, 50, `Ronda: ${this.round}`, { fontSize: '24px', fill: '#ffffff' });

        this.music = this.sound.get('musica');
        if (this.music && !this.music.isPlaying) {
            this.music.play();
        }
    }

    createPath() {
        let path = this.add.path(50, 100);
        path.lineTo(150, 150);
        path.lineTo(300, 250);
        path.lineTo(400, 350);
        path.lineTo(550, 400);
        path.lineTo(750, 500);
        return path;
    }

    drawPath() {
        this.graphics.lineStyle(4, 0xffffff, 1);
        this.path.draw(this.graphics);
    }

    spawnEnemy() {
        // Generar un nuevo enemigo
        let enemyType = Phaser.Math.RND.pick(['verde', 'azul', 'rojo']);
        let enemySprite = this.add.sprite(0, 0, enemyType).setScale(0.5);
        
        let enemy = {
            sprite: enemySprite,
            t: 0,
            speed: 1 / 5000,
            dead: false,
            lives: enemyType === 'verde' ? 3 : (enemyType === 'azul' ? 2 : 1)
        };

        this.enemies.push(enemy);

        // Controlar el nÃºmero de enemigos si se han derrotado suficientes
        this.enemiesDefeated++;
        if (this.enemiesDefeated >= 10) {
            this.round++;
            this.displayRound();
            this.enemiesDefeated = 0; // Reiniciar el contador de enemigos derrotados

            // Aumentar la velocidad de apariciÃ³n de enemigos cada ronda
            this.enemySpawnInterval = Math.max(2000, this.enemySpawnInterval * 0.9); // Minimum 2 segundos
            this.spawnTimer.delay = this.enemySpawnInterval; // Actualizar el temporizador de spawn
            
            if (this.round % 10 === 0) {
                this.spawnBoss(); // Llama a la funciÃ³n para hacer aparecer un jefe
            }

            // Si se llega a la ronda 100
            if (this.round > 100) {
                this.showWinScreen();
                return;
            }
        }
    }

    displayRound() {
        this.roundText.setText(`Ronda: ${this.round}`);
    }

    showWinScreen() {
        this.spawnTimer.remove();
        this.add.text(250, 250, 'Â¡Has ganado!', { fontSize: '48px', fill: '#00ff00' });
        this.add.text(200, 350, 'Volver al menÃº...', { fontSize: '32px', fill: '#ffffff' });

        this.time.addEvent({
            delay: 3000,
            callback: () => {
                this.scene.start('MenuScene');
            },
            callbackScope: this
        });
    }

    spawnBoss() {
        let bossType = Phaser.Math.RND.pick(['verde', 'azul', 'rojo']);
        let enemySprite = this.add.sprite(0, 0, bossType).setScale(1); // Cambia el tamaÃ±o del jefe
        let boss = {
            sprite: enemySprite,
            t: 0,
            speed: 1 / 3000, // Jefe lento
            dead: false,
            lives: 10 // 10 de vida para el jefe
        };
        this.enemies.push(boss);
    }

    createUI() {
        this.add.rectangle(400, 550, 800, 100, 0x222222);
        let tower1Button = this.add.image(350, 550, 'morada').setScale(0.5).setInteractive();
        let tower2Button = this.add.image(450, 550, 'amarilla').setScale(0.5).setInteractive();

        tower1Button.on('pointerdown', () => {
            if (this.money >= 50) {
                this.selectedTower = 'morada';
                this.money -= 50;
            }
        });

        tower2Button.on('pointerdown', () => {
            if (this.money >= 100) {
                this.selectedTower = 'amarilla';
                this.money -= 100;
            }
        });
    }

    setupTowerPlacement() {
        this.input.on('pointerdown', (pointer) => {
            if (this.selectedTower && pointer.y < 500) {
                let tower = this.add.sprite(pointer.x, pointer.y, this.selectedTower).setScale(0.5);
                this.towers.push(tower);
                this.selectedTower = null;
            }
        });
    }

    shootFromTowers() {
        this.towers.forEach(tower => {
            let closest = null;
            let minDist = 150;

            this.enemies.forEach(enemy => {
                if (enemy.dead) return;
                let dist = Phaser.Math.Distance.Between(tower.x, tower.y, enemy.sprite.x, enemy.sprite.y);
                if (dist < minDist) {
                    minDist = dist;
                    closest = enemy;
                }
            });

            if (closest) {
                const damage = tower.texture.key === 'morada' ? 1 : 3; // DaÃ±o segÃºn el tipo de torre
                const bullet = this.add.image(tower.x, tower.y, 'bala').setScale(0.3);
                const dx = closest.sprite.x - tower.x;
                const dy = closest.sprite.y - tower.y;
                const angle = Math.atan2(dy, dx);
                const speed = 300;

                bullet.setRotation(angle);
                bullet.vx = Math.cos(angle) * speed;
                bullet.vy = Math.sin(angle) * speed;
                bullet.target = closest;
                bullet.damage = damage; // Asigna daÃ±o a la bala

                bullet.update = (delta) => {
                    bullet.x += bullet.vx * delta;
                    bullet.y += bullet.vy * delta;

                    if (bullet.target && !bullet.target.dead) {
                        const dist = Phaser.Math.Distance.Between(
                            bullet.x, bullet.y,
                            bullet.target.sprite.x, bullet.target.sprite.y
                        );
                        if (dist < 35) {
                            bullet.destroy();
                            // Restamos vida segÃºn el daÃ±o de la bala
                            bullet.target.lives -= bullet.damage;
                            if (bullet.target.lives <= 0) {
                                this.money += 10; // Recompensa por eliminar un enemigo
                                // Transformar el enemigo
                                if (bullet.target.sprite.texture.key === 'verde') {
                                    bullet.target.sprite.setTexture('azul');
                                    bullet.target.lives = 2; 
                                } else if (bullet.target.sprite.texture.key === 'azul') {
                                    bullet.target.sprite.setTexture('rojo');
                                    bullet.target.lives = 1; 
                                } else {
                                    bullet.target.dead = true;
                                    bullet.target.sprite.destroy();
                                }
                            }
                        }
                    } else {
                        bullet.destroy();
                    }
                };

                this.bullets.add(bullet);
            }
        });
    }

    update(time, delta) {
        // Movimiento de enemigos
        this.enemies.forEach(enemy => {
            if (!enemy.dead) {
                enemy.t += enemy.speed * delta;
                if (enemy.t >= 1) {
                    enemy.dead = true;
                    enemy.sprite.destroy();
                    this.lives -= 1; // PÃ©rdida de vidas del jugador
                    if (this.lives <= 0) this.scene.start('MenuScene'); // Finalizar si se muere
                } else {
                    let point = this.path.getPoint(enemy.t);
                    enemy.sprite.setPosition(point.x, point.y);
                }
            }
        });

        // Actualizar balas
        this.bullets.getChildren().forEach(bullet => {
            if (bullet.update) bullet.update(delta / 1000);
        });

        // Actualizar HUD
        this.infoText.setText(`Vidas: ${this.lives} | Dinero: $${this.money}`);
    }
}

const config = {
    type: Phaser.AUTO,
    width: 800,
    height: 600,
    scene: [MenuScene, TowerDefenseGame],
    physics: { default: 'arcade' },
    parent: document.body
};

const game = new Phaser.Game(config);
</script>
</body>
</html>
